<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Who's That Pokémon?</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            height: 100vh; /* Fallback */
            height: 100dvh; /* Mobile dynamic viewport */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            background-color: #EF4036;
            font-family: 'Poppins', sans-serif;
            overflow: hidden;
            transition: background-color 0.05s;
        }

        .header {
            padding: 40px;
            position: relative;
            z-index: 10;
        }

        h1 {
            color: white;
            font-size: 5rem;
            line-height: 1.1;
            margin: 0 0 40px 0;
            text-transform: none;
            max-width: 800px;
            pointer-events: none; /* Let touches pass through title */
        }

        input {
            background: white;
            border: none;
            height: 80px;
            width: 400px;
            font-size: 2rem;
            padding: 0 20px;
            font-family: 'Poppins', sans-serif;
            color: #333;
            outline: none;
            display: block;
            border-radius: 4px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }

        .pokemon-container {
            position: absolute;
            bottom: -2vh;
            right: -2vh;
            width: 55vh; /* Slightly smaller to ensure fit */
            height: 55vh;
            display: flex;
            align-items: flex-end;
            justify-content: flex-end;
            z-index: 5;
            pointer-events: none;
        }

        img {
            width: 100%;
            height: auto;
            object-fit: contain;
            filter: brightness(0) invert(1);
            /* Smoothly fade the image in/out if src changes rapidly */
            transition: opacity 0.2s; 
        }

        /* Canvas Overlay */
        #transitionCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        /* --- Mobile Optimizations --- */
        @media (max-width: 768px) {
            .header { padding: 20px; }
            
            h1 { 
                font-size: 3rem; 
                margin-bottom: 20px; 
            }
            
            input { 
                width: 90%; 
                height: 60px;
                /* Prevents iOS zoom on focus */
                font-size: 1.2rem; 
            }
            
            .pokemon-container { 
                width: 85vw; 
                height: 85vw; 
                right: -5vw;
                bottom: -5vw;
            }
        }
    </style>
</head>
<body>

    <canvas id="transitionCanvas"></canvas>

    <div class="header">
        <h1>Who's that<br>Pokémon?</h1>
        <input type="text" id="guessInput" autofocus autocomplete="off" spellcheck="false">
    </div>

    <div class="pokemon-container">
        <img id="pokeImage" src="" alt="Pokemon">
    </div>

    <script src="./gamedata.js"></script> 
    
    <script>
        // --- Configuration ---
        const BLOCK_SIZE = 60; 
        const TRANSITION_SPEED_MODIFIER = 0.6; // Lower = Faster
        
        // --- Global State ---
        let currentIndex = 0;
        const input = document.getElementById('guessInput');
        const img = document.getElementById('pokeImage');
        const body = document.body;
        const canvas = document.getElementById('transitionCanvas');
        const ctx = canvas.getContext('2d');
        let isTransitioning = false;

        // --- Utils: Randomizer ---
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // --- Utils: Color Palette ---
        function generatePalette(rawHex) {
            // FIXED: Handle hex codes with or without the hash
            let c = rawHex.startsWith('#') ? rawHex.substring(1) : rawHex;
            
            let rgb = parseInt(c, 16);
            let r = (rgb >> 16) & 0xff;
            let g = (rgb >>  8) & 0xff;
            let b = (rgb >>  0) & 0xff;

            const palette = [];
            palette.push(`rgb(${r*0.5}, ${g*0.5}, ${b*0.5})`); // Deep Shade
            palette.push(`rgb(${r*0.8}, ${g*0.8}, ${b*0.8})`); // Shade
            palette.push(`rgb(${r}, ${g}, ${b})`);             // Base
            palette.push(`rgb(${r + (255-r)*0.3}, ${g + (255-g)*0.3}, ${b + (255-b)*0.3})`); // Tint
            palette.push(`rgb(${r + (255-r)*0.6}, ${g + (255-g)*0.6}, ${b + (255-b)*0.6})`); // Light Tint
            return palette;
        }

        // --- Utils: Easing ---
        // easeInOutQuint: More dramatic acceleration/deceleration
        function easeInOutQuint(x) {
            return x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2;
        }

        // --- Transition Logic ---
        function runSmartTransition(nextColor, onComplete) {
            if (isTransitioning) return;
            isTransitioning = true;

            const width = window.innerWidth;
            const height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;

            const cols = Math.ceil(width / BLOCK_SIZE);
            const rows = Math.ceil(height / BLOCK_SIZE);
            const palette = generatePalette(nextColor);

            // Generate Grid with random delays
            let blocks = [];
            const maxDelay = 400 * TRANSITION_SPEED_MODIFIER; 
            
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    blocks.push({
                        c: c, r: r,
                        color: palette[Math.floor(Math.random() * palette.length)], 
                        delay: Math.random() * maxDelay, 
                        scale: 0 
                    });
                }
            }

            let startTime = null;
            const growDuration = 350 * TRANSITION_SPEED_MODIFIER; 
            const totalDuration = maxDelay + growDuration + 50; 

            // PHASE 1: IN
            function animateIn(timestamp) {
                if (!startTime) startTime = timestamp;
                let elapsed = timestamp - startTime;
                
                ctx.clearRect(0, 0, width, height);

                blocks.forEach(block => {
                    let blockTime = elapsed - block.delay;
                    if (blockTime < 0) blockTime = 0;
