<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Who's That Pokémon?</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            height: 100vh; /* Fallback */
            height: 100dvh; /* Mobile dynamic viewport */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            background-color: #EF4036;
            font-family: 'Poppins', sans-serif;
            overflow: hidden;
            transition: background-color 0.05s;
        }

        .header {
            padding: 40px;
            position: relative;
            z-index: 10;
        }

        h1 {
            color: white;
            font-size: 5rem;
            line-height: 1.1;
            margin: 0 0 40px 0;
            text-transform: none;
            max-width: 800px;
            pointer-events: none; /* Let touches pass through title */
        }

        input {
            background: white;
            border: none;
            height: 80px;
            width: 400px;
            font-size: 2rem;
            padding: 0 20px;
            font-family: 'Poppins', sans-serif;
            color: #333;
            outline: none;
            display: block;
            border-radius: 4px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }

        .pokemon-container {
            position: absolute;
            bottom: -2vh;
            right: -2vh;
            width: 55vh; /* Slightly smaller to ensure fit */
            height: 55vh;
            display: flex;
            align-items: flex-end;
            justify-content: flex-end;
            z-index: 5;
            pointer-events: none;
        }

        img {
            width: 100%;
            height: auto;
            object-fit: contain;
            filter: brightness(0) invert(1);
            /* Smoothly fade the image in/out if src changes rapidly */
            transition: opacity 0.2s; 
        }

        /* Canvas Overlay */
        #transitionCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        /* --- Mobile Optimizations --- */
        @media (max-width: 768px) {
            .header { padding: 20px; }
            
            h1 { 
                font-size: 3rem; 
                margin-bottom: 20px; 
            }
            
            input { 
                width: 90%; 
                height: 60px;
                /* Prevents iOS zoom on focus */
                font-size: 1.2rem; 
            }
            
            .pokemon-container { 
                width: 85vw; 
                height: 85vw; 
                right: -5vw;
                bottom: -5vw;
            }
        }
    </style>
</head>
<body>

    <canvas id="transitionCanvas"></canvas>

    <div class="header">
        <h1>Who's that<br>Pokémon?</h1>
        <input type="text" id="guessInput" autofocus autocomplete="off" spellcheck="false">
    </div>

    <div class="pokemon-container">
        <img id="pokeImage" src="" alt="Pokemon">
    </div>

    <script src="gamedata.js"></script> 
    
    <script>
        // --- Configuration ---
        const BLOCK_SIZE = 60; 
        const TRANSITION_SPEED_MODIFIER = 0.6; // Lower = Faster (0.6 is 60% of original time)
        
        // --- Global State ---
        let currentIndex = 0;
        const input = document.getElementById('guessInput');
        const img = document.getElementById('pokeImage');
        const body = document.body;
        const canvas = document.getElementById('transitionCanvas');
        const ctx = canvas.getContext('2d');
        let isTransitioning = false;

        // --- Utils: Randomizer ---
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // --- Utils: Color Palette ---
        function generatePalette(hex) {
            let c = hex.substring(1); 
            let rgb = parseInt(c, 16);
            let r = (rgb >> 16) & 0xff;
            let g = (rgb >>  8) & 0xff;
            let b = (rgb >>  0) & 0xff;

            const palette = [];
            palette.push(`rgb(${r*0.5}, ${g*0.5}, ${b*0.5})`); // Deep Shade
            palette.push(`rgb(${r*0.8}, ${g*0.8}, ${b*0.8})`); // Shade
            palette.push(`rgb(${r}, ${g}, ${b})`);             // Base
            palette.push(`rgb(${r + (255-r)*0.3}, ${g + (255-g)*0.3}, ${b + (255-b)*0.3})`); // Tint
            palette.push(`rgb(${r + (255-r)*0.6}, ${g + (255-g)*0.6}, ${b + (255-b)*0.6})`); // Light Tint
            return palette;
        }

        // --- Utils: Easing ---
        // easeInOutQuint: More dramatic acceleration/deceleration
        function easeInOutQuint(x) {
            return x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2;
        }

        // --- Transition Logic ---
        function runSmartTransition(nextColor, onComplete) {
            if (isTransitioning) return;
            isTransitioning = true;

            const width = window.innerWidth;
            const height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;

            const cols = Math.ceil(width / BLOCK_SIZE);
            const rows = Math.ceil(height / BLOCK_SIZE);
            const palette = generatePalette(nextColor);

            // Generate Grid with random delays
            let blocks = [];
            // Reduced max delay for snappier feel
            const maxDelay = 400 * TRANSITION_SPEED_MODIFIER; 
            
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    blocks.push({
                        c: c, r: r,
                        color: palette[Math.floor(Math.random() * palette.length)], 
                        delay: Math.random() * maxDelay, 
                        scale: 0 
                    });
                }
            }

            let startTime = null;
            // Faster block growth
            const growDuration = 350 * TRANSITION_SPEED_MODIFIER; 
            const totalDuration = maxDelay + growDuration + 50; 

            // PHASE 1: IN
            function animateIn(timestamp) {
                if (!startTime) startTime = timestamp;
                let elapsed = timestamp - startTime;
                let allDone = true;

                ctx.clearRect(0, 0, width, height);

                blocks.forEach(block => {
                    let blockTime = elapsed - block.delay;
                    if (blockTime < 0) blockTime = 0;
                    
                    let progress = Math.min(blockTime / growDuration, 1);
                    if (progress < 1) allDone = false;

                    let easedScale = easeInOutQuint(progress);

                    if (easedScale > 0) {
                        ctx.fillStyle = block.color;
                        let size = BLOCK_SIZE * easedScale;
                        // Overlap slightly to prevent hairline cracks
                        let drawSize = size + 1.5; 
                        let offset = (BLOCK_SIZE - size) / 2;
                        
                        ctx.fillRect(
                            block.c * BLOCK_SIZE + offset, 
                            block.r * BLOCK_SIZE + offset, 
                            drawSize, drawSize
                        );
                    }
                });

                if (elapsed < totalDuration) {
                    requestAnimationFrame(animateIn);
                } else {
                    onComplete(); // Swap Background/Pokemon
                    
                    // Reset for Out Phase
                    startTime = null;
                    // Reshuffle delays for variety
                    blocks.forEach(b => b.delay = Math.random() * maxDelay); 
                    requestAnimationFrame(animateOut);
                }
            }

            // PHASE 2: OUT
            function animateOut(timestamp) {
                if (!startTime) startTime = timestamp;
                let elapsed = timestamp - startTime;
                
                ctx.clearRect(0, 0, width, height);
                
                // Helper to check if canvas is clear
                let drawnCount = 0;

                blocks.forEach(block => {
                    let blockTime = elapsed - block.delay;
                    if (blockTime < 0) blockTime = 0;
                    
                    let progress = Math.min(blockTime / growDuration, 1);
                    
                    // Reverse easing
                    let easedScale = 1 - easeInOutQuint(progress);

                    if (easedScale > 0.01) {
                        drawnCount++;
                        ctx.fillStyle = block.color;
                        let size = BLOCK_SIZE * easedScale;
                        let drawSize = size + 1.5;
                        let offset = (BLOCK_SIZE - size) / 2;
                        ctx.fillRect(
                            block.c * BLOCK_SIZE + offset, 
                            block.r * BLOCK_SIZE + offset, 
                            drawSize, drawSize
                        );
                    }
                });

                if (elapsed < totalDuration && drawnCount > 0) {
                    requestAnimationFrame(animateOut);
                } else {
                    ctx.clearRect(0, 0, width, height);
                    isTransitioning = false;
                    input.focus();
                }
            }

            requestAnimationFrame(animateIn);
        }

        // --- Game Logic ---
        function getEditDistance(a, b) {
            if (a.length === 0) return b.length; 
            if (b.length === 0) return a.length; 
            var matrix = [];
            for (let i = 0; i <= b.length; i++) { matrix[i] = [i]; }
            for (let j = 0; j <= a.length; j++) { matrix[0][j] = j; }
            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    if (b.charAt(i-1) == a.charAt(j-1)) {
                        matrix[i][j] = matrix[i-1][j-1];
                    } else {
                        matrix[i][j] = Math.min(matrix[i-1][j-1] + 1, Math.min(matrix[i][j-1] + 1, matrix[i-1][j] + 1));
                    }
                }
            }
            return matrix[b.length][a.length];
        }

        function loadPokemon() {
            if (currentIndex >= window.pokemonList.length) {
                // Optional: Reshuffle and restart?
                alert("You caught them all! Reloading...");
                location.reload();
                return;
            }
            const currentData = window.pokemonList[currentIndex];
            img.src = "./images/" + currentData.filename;
            body.style.backgroundColor = currentData.color;
            input.value = "";
        }

        function checkAnswer() {
            if (isTransitioning) return;

            const userGuess = input.value.toLowerCase().trim();
            const currentData = window.pokemonList[currentIndex];
            const correctName = currentData.name.toLowerCase();
            
            const allowedErrors = correctName.length > 6 ? 2 : 1;
            const distance = getEditDistance(userGuess, correctName);

            if (distance <= allowedErrors && userGuess.length > 0) {
                
                // Determine NEXT color for transition
                let nextColor = currentData.color; 
                if (currentIndex + 1 < window.pokemonList.length) {
                    nextColor = window.pokemonList[currentIndex + 1].color;
                }

                runSmartTransition(nextColor, () => {
                    currentIndex++;
                    loadPokemon();
                });
            }
        }

        // --- Initialization ---
        input.addEventListener('input', checkAnswer);
        window.addEventListener('resize', () => {
             canvas.width = window.innerWidth;
             canvas.height = window.innerHeight;
        });

        // Start Game
        if (window.pokemonList) {
            // 1. Randomize the list
            shuffleArray(window.pokemonList);
            // 2. Load first
            loadPokemon();
        } else {
            console.error("gamedata.js not found");
        }
    </script>
</body>
</html>